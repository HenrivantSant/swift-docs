(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{131:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n(3),r=n(7),o=(n(0),n(141)),i={title:"Routing & Controllers"},s={unversionedId:"routing-and-controllers",id:"routing-and-controllers",isDocsHomePage:!1,title:"Routing & Controllers",description:"When your application receives a request, it calls a controller action (method on a controller) to generate the response. The routing configuration defines which action to run for each incoming URL. It also provides other useful features, like generating SEO-friendly URLs (e.g. /read/intro-to-swift instead of index.php?article_id=57).",source:"@site/docs/routing-and-controllers.md",slug:"/routing-and-controllers",permalink:"/swift-docs/docs/routing-and-controllers",editUrl:"https://github.com/SwiftAPI/swift-docs/tree/main/docs/routing-and-controllers.md",version:"current",sidebar:"docs",previous:{title:"Making requests",permalink:"/swift-docs/docs/making-requests"},next:{title:"Introduction",permalink:"/swift-docs/docs/security/introduction"}},l=[{value:"Controllers",id:"controllers",children:[]},{value:"Route Attribute",id:"route-attribute",children:[{value:"Variables in urls",id:"variables-in-urls",children:[]},{value:"Reading url variables",id:"reading-url-variables",children:[]}]},{value:"Responses",id:"responses",children:[{value:"Exceptions",id:"exceptions",children:[]}]},{value:"Hooking in to the router (Route Events)",id:"hooking-in-to-the-router-route-events",children:[{value:"Register your own variable types (MatchTypes)",id:"register-your-own-variable-types-matchtypes",children:[]},{value:"Adding/modifying routes",id:"addingmodifying-routes",children:[]}]}],c={toc:l};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"When your application receives a request, it calls a controller action (method on a controller) to generate the response. The routing configuration defines which action to run for each incoming URL. It also provides other useful features, like generating SEO-friendly URLs (e.g. /read/intro-to-swift instead of index.php?article_id=57)."),Object(o.b)("h2",{id:"controllers"},"Controllers"),Object(o.b)("p",null,"Controllers are classes in which available routes are defined and in which actions based on the route will be executed. Controllers must be created in the app directory in your app. For example 'app/Foo/Controller/' and should extend 'Swift\\Controller\\AbstractController'. This way the Router will know this is a controller class and map the routes."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-php"},"declare(strict_types=1);\n\nnamespace App\\Foo\\Controller;\n\nuse App\\Foo\\Service\\FooService;\nuse Swift\\Configuration\\ConfigurationInterface;\nuse Swift\\Controller\\AbstractController;\nuse Swift\\HttpFoundation\\JsonResponse;\nuse Swift\\Router\\Attributes\\Route;\nuse Swift\\Router\\RouteParameterBag;\nuse Swift\\Router\\Types\\RouteMethod;\n\n/**\n * class FooController\n * @package Foo\\Controller\n */\n#[Route(method: [RouteMethod::GET, RouteMethod::PATCH], route: '/foo/', name: 'foo')]\nclass FooController extends AbstractController {\n\n    /**\n     * Foo constructor.\n     *\n     * @param ConfigurationInterface $configuration\n     * @param FooService $fooService\n     * @param string|null $notAutowired\n     */\n    public function __construct(\n        protected ConfigurationInterface $configuration,\n        protected FooService $fooService,\n        protected ?string $notAutowired = null,\n    ) {\n    }\n\n    /**\n     * @param RouteParameterBag $params\n     *\n     * @return JSONResponse\n     */\n    #[Route(method: [RouteMethod::GET], route: '/bar/[i:article_id]/', name: 'foo.get_bar')]\n    public function getBar( RouteParameterBag $params): JsonResponse {\n        // Let's return the article here\n\n        $article_id = $params->get('article_id')->getValue();\n\n        return new JsonResponse( [\n            'article_id' => $article_id,\n            'title' => 'Foo Bar',\n        ] );\n    }\n\n    /**\n     * @param RouteParameterBag $params\n     *\n     * @return JsonResponse\n     */\n    #[Route(method: [RouteMethod::PATCH], route: '/bar/[i:article_id]/', name: 'foo.patch_bar')]\n    public function patchBar( RouteParameterBag $params): JsonResponse {\n        // Let's update the article here\n        return new JsonResponse( ['foo bar' ] );\n    }\n}\n")),Object(o.b)("p",null,"Don't worry too much about what's going on above, but here is a basic example of a route. In this example we expose the route 'foo/bar' for all GET requests. How come? On the class of the controller you can provide a prefix for all controllers routes. This is highly recommended to force you to group specific routes and use different controllers for different kinds of stuff."),Object(o.b)("p",null,"On the method ",Object(o.b)("inlineCode",{parentName:"p"},"getBar()")," we expose the route '/bar'/ which will be prefixed with the class route. So this results in '/foo/bar'. The moment this route is matched this method will be called. This is the first point entry for the actual app logic. All the data from the request can be found in the Request which is available in the controller by default. All the request data is accessible through ",Object(o.b)("inlineCode",{parentName:"p"},"$this->getRequest()"),". Note that route definitions by convention always start and end with forward slashes."),Object(o.b)("p",null,"But what if you want a variable like an id? More on the specifics of building the Route Annotation in the chapter 'Route Attribute'. "),Object(o.b)("p",null,"NOTE: Multiple types can be exposed for a given route. Also, the same route can lead to different methods on the controller based on the Method used to make the request. The class route must allow for all HTTP Methods used in the definitions within. Type HTTP methods in writing (uppercase) or simple refer using the ",Object(o.b)("inlineCode",{parentName:"p"},"Swift\\Router\\Types\\RouteMethod")," as in the example above. "),Object(o.b)("h2",{id:"route-attribute"},"Route Attribute"),Object(o.b)("p",null,"The Router will 'collect' all methods in the controllers classes with a ",Object(o.b)("inlineCode",{parentName:"p"},"#[Route]")," attribute, and map those as routes. If a route attribute is used on the class (highly recommended) this will be used as a prefix for all methods in this specific controller as explained in the example above."),Object(o.b)("p",null,"The attributes come with the following settings:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"method = Allowed HTTP methods to call this route (e.g. GET, POST, PATCH, PUT, etc.). Multiple methods can be provided together like ",Object(o.b)("inlineCode",{parentName:"li"},'#[Route(method="[GET, POST, PUT]", route="/bar/"]'),". Usually this should only be necessary on the class. There is no wildcard to allow all methods as you should normally not direct a GET request for data to the same functionality as e.g. a POST request.")),Object(o.b)("p",null,"This means you could have the same route for different HTTP Methods if you would desire this. You can have an endpoint ",Object(o.b)("inlineCode",{parentName:"p"},"/article/[i:id]/"),", where the GET would lead to method which would return the value of the article with the given id, and where PATCH for example to this same endpoint would update the given article. Makes sense to split this into different methods right?"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"route = The route for this method with a leading and closing slash"),Object(o.b)("li",{parentName:"ul"},"name = Make the route easy to find back in the router and allow for reversed routing"),Object(o.b)("li",{parentName:"ul"},"isGranted = Validate user is granted certain rights or status. More on this in de Security documentation"),Object(o.b)("li",{parentName:"ul"},"tags = Provide a route with certain tags. E.g. the Security component uses this to define a route as authentication endpoint.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-php"},"   /**\n     * Rest user authentication endpoint\n     *\n     * Authentication already occurs on the security component. So all that needs to be done is return the currently authenticated user\n     *\n     * Only a direct login is valid here. Re-authentication or no authentication is not valid. This is already cover through isGranted in the route (validated by the firewall)\n     *\n     * @param RouteParameter[] $params\n     *\n     * @return JsonResponse\n     */\n    #[Route( method: [RouteMethodEnum::POST], route: '/login/', name: 'security.user.login', isGranted: [AuthorizationType::IS_AUTHENTICATED_DIRECTLY], tags: [Route::TAG_ENTRYPOINT] )]\n    public function login( RouteParameterBag $params ): JsonResponse {\n        $data = $this->getCurrentUser()?->serialize();\n        $data->token = new \\stdClass();\n        $data->token->token = $this->getSecurityToken()->getTokenString();\n        $data->token->expires = $this->getSecurityToken()->expiresAt()->format('Y-m-d H:i:s');\n\n        return new JsonResponse($data);\n    }\n")),Object(o.b)("h3",{id:"variables-in-urls"},"Variables in urls"),Object(o.b)("p",null,"Note: This principle is fork of ",Object(o.b)("a",{parentName:"p",href:"https://github.com/dannyvankooten/AltoRouter"},"AltoRouter"),".",Object(o.b)("br",{parentName:"p"}),"\n","As you can see in the previous example there some weird syntax going on in the route parameter in the attribute. This a route 'variable' with the name 'article_id'. Each route can have multiple variables which allows for the url to be like '/bar/123'."),Object(o.b)("p",null,"Variables always follow the syntax ",Object(o.b)("inlineCode",{parentName:"p"},"[variable_type:variable_name]"),". Variable types are predefined and the variable name is up to yourself, you will need the variable name to extract it's value later (123 in this case)."),Object(o.b)("p",null,"Predefined variable types:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-php"},"*                    // Match all request URIs\n[i]                  // Match an integer\n[i:id]               // Match an integer as 'id'\n[a:action]           // Match alphanumeric characters as 'action'\n[h:key]              // Match hexadecimal characters as 'key'\n[:action]            // Match anything up to the next / or end of the URI as 'action'\n[create|edit:action] // Match either 'create' or 'edit' as 'action'\n[*]                  // Catch all (lazy, stops at the next trailing slash)\n[*:trailing]         // Catch all as 'trailing' (lazy)\n[**:trailing]        // Catch all (possessive - will match the rest of the URI)\n.[:format]?          // Match an optional parameter 'format' - a / or . before the block is also optional\n")),Object(o.b)("p",null,"Each of those variable types results in a regex"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-php"},"'i'  => '[0-9]++'\n'a'  => '[0-9A-Za-z]++'\n'h'  => '[0-9A-Fa-f]++'\n'*'  => '.+?'\n'**' => '.++'\n''   => '[^/\\.]++'\n")),Object(o.b)("p",null,"It is possible to register your custom variable types to router if you wish to match a specific pattern. More on this in the chapter 'Hooking in to the router'."),Object(o.b)("h3",{id:"reading-url-variables"},"Reading url variables"),Object(o.b)("p",null,"Okay so we can use several variables, convenient! How to read this? Easy! The variables which be passed into your function as an ",Object(o.b)("inlineCode",{parentName:"p"},"Swift\\Router\\RouteParameterBag"),". See the example below."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-php"},"    /**\n     * @param RouteParameter[] $params\n     *\n     * @return JSONResponse\n     */\n    #[Route(method: [RouteMethodEnum::GET], route: '/bar/[i:article_id]/', name: 'foo.get_bar')]\n    public function getBar( RouteParameterBag $params): JsonResponse {\n        // Let's return the article here\n\n        $article_id = $params->get('article_id')->getValue();\n\n        return new JsonResponse( [\n            'article_id' => $article_id,\n            'title' => 'Foo Bar',\n        ] );\n    }\n")),Object(o.b)("p",null,"See how the variable name comes in to play now? See ",Object(o.b)("a",{parentName:"p",href:"https://github.com/HenrivantSant/swift/blob/master/src/Router/RouteParameter.php"},Object(o.b)("inlineCode",{parentName:"a"},"Swift\\Router\\RouteParameter"))),Object(o.b)("h2",{id:"responses"},"Responses"),Object(o.b)("p",null,"A controller action must always return a ",Object(o.b)("a",{parentName:"p",href:"https://github.com/HenrivantSant/swift/blob/master/src/HttpFoundation/ResponseInterface.php"},Object(o.b)("inlineCode",{parentName:"a"},"Swift\\HTTPFoundation\\ResponseInterface"))," instance. This will output the given payload as JSON. You can easily add different Responses as long as they extend from ",Object(o.b)("inlineCode",{parentName:"p"},"Swift\\HTTPFoundation\\Response"),", or make one from scratch. As long as it implements the interface all is good. There are some defaults at your disposal:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"https://github.com/HenrivantSant/swift/blob/master/src/HttpFoundation/Response.php"},Object(o.b)("inlineCode",{parentName:"a"},"Swift\\HttpFoundation\\Response"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"https://github.com/HenrivantSant/swift/blob/master/src/HttpFoundation/JsonResponse.php"},Object(o.b)("inlineCode",{parentName:"a"},"Swift\\HttpFoundation\\JsonResponse"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"https://github.com/HenrivantSant/swift/blob/master/src/HttpFoundation/RedirectResponse.php"},Object(o.b)("inlineCode",{parentName:"a"},"Swift\\HttpFoundation\\RedirectResponse"))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",{parentName:"li",href:"https://github.com/HenrivantSant/swift/blob/master/src/HttpFoundation/BinaryFileResponse.php"},Object(o.b)("inlineCode",{parentName:"a"},"Swift\\HttpFoundation\\BinaryFileResponse")))),Object(o.b)("p",null,"The above controller called with 'foo/bar/3' with HTTP GET would return:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-json"},'{\n    "article_id": 3,\n    "title": "Foo Bar"\n}\n')),Object(o.b)("p",null,"In the real world you would likely fetch some data or execute certain logic."),Object(o.b)("h3",{id:"exceptions"},"Exceptions"),Object(o.b)("p",null,"For some 'simple' responses it's not necessary to give a response. You can simply throw an Exception and the system will catch it, and deal with it accordingly. Those are available right now:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Swift\\HTTPFoundation\\Exceptions\\BadRequestException")," => Will return a 400 status code"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Swift\\HTTPFoundation\\Exceptions\\InternalErrorException")," => Will return a 500 status code"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Swift\\HTTPFoundation\\Exceptions\\NotAuthorizedException")," => Will return a 401 status code"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Swift\\HTTPFoundation\\Exceptions\\AccessDeniedException")," => Will return a 403 status code"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Swift\\HTTPFoundation\\Exceptions\\NotFoundException")," => Will return a 404 status code\nNote that with 400 errors the exception message will be passed the client too. If it's empty it defaults the Mozilla errors text defaults.")),Object(o.b)("p",null,"With error message:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-json"},'{\n    "message": "Token has expired",\n    "code": 401\n}\n')),Object(o.b)("p",null,"Without message:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-json"},'{\n    "message": "Unauthorized",\n    "code": 401\n}\n')),Object(o.b)("h2",{id:"hooking-in-to-the-router-route-events"},"Hooking in to the router (Route Events)"),Object(o.b)("p",null,"TODO"),Object(o.b)("h3",{id:"register-your-own-variable-types-matchtypes"},"Register your own variable types (MatchTypes)"),Object(o.b)("p",null,"As discussed before it's possible to define variables in route declarations. Those variables are declared by MatchTypes. It's possible to add custom types (regexes). To do so, create a class implementing the ",Object(o.b)("inlineCode",{parentName:"p"},"Swift\\Router\\MatchTypes\\MatchTypeInterface"),". Below an example of the AlphaNumeric MatchType."),Object(o.b)("p",null,"There's three methods to implement here."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"getIdentifier() -> return name of MatchType, the router will use this to identify back to this MatchType from usage in the route declaring ('/foo/bar/","[a:example]","')"),Object(o.b)("li",{parentName:"ul"},"getRegex() -> Regex pattern to match for this MatchType"),Object(o.b)("li",{parentName:"ul"},"parseValue() -> If the route has matched the MatchType it will call the parseValue method to (optionally) parse the value. In this example we specifically return a string, but any type is allowed by the Interface (mixed).")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-php"},"declare(strict_types=1);\n\nnamespace Swift\\Router\\MatchTypes;\n\nuse Swift\\HttpFoundation\\RequestInterface;\n\n/**\n * Class Integer\n * @package Swift\\Router\\MatchTypes\n *\n * Match alphanumeric characters\n */\nclass AlphaNumeric implements MatchTypeInterface {\n\n    public const IDENTIFIER = 'a';\n    public const REGEX = '[0-9A-Za-z]++';\n\n    /**\n     * @inheritDoc\n     */\n    public function getIdentifier(): string {\n        return static::IDENTIFIER;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public function getRegex(): string {\n        return static::REGEX;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    public function parseValue( mixed $value, RequestInterface $request ): string {\n        return preg_replace('/[^\\da-z]/i', '', $value);\n    }\n\n}\n")),Object(o.b)("h3",{id:"addingmodifying-routes"},"Adding/modifying routes"),Object(o.b)("p",null,"TODO"))}u.isMDXComponent=!0},141:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),u=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,b=p["".concat(i,".").concat(d)]||p[d]||h[d]||o;return n?r.a.createElement(b,s(s({ref:t},c),{},{components:n})):r.a.createElement(b,s({ref:t},c))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);