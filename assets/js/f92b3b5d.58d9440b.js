(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{140:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var i=n(3),r=n(7),a=(n(0),n(148)),o={title:"Rate Limiter"},s={unversionedId:"security/ratelimiter",id:"security/ratelimiter",isDocsHomePage:!1,title:"Rate Limiter",description:"The rate limiter is responsible for limiting the rate of requests a user can make to the application within a given time period. This is useful for preventing a user from spamming the application, but mainly to control the amount of requests a user is allowed to make. The rate limiter is configured in the etc/config/security.yaml file.",source:"@site/docs/security/ratelimiter.md",slug:"/security/ratelimiter",permalink:"/swift-docs/docs/security/ratelimiter",editUrl:"https://github.com/SwiftAPI/swift-docs/tree/main/docs/security/ratelimiter.md",version:"current",sidebar:"docs",previous:{title:"Firewall",permalink:"/swift-docs/docs/security/firewall"},next:{title:"Users (& Clients)",permalink:"/swift-docs/docs/security/users"}},c=[{value:"Default Rate Limiter",id:"default-rate-limiter",children:[{value:"GraphQL Rate Limiter",id:"graphql-rate-limiter",children:[]}]},{value:"Custom Rate Limiter",id:"custom-rate-limiter",children:[{value:"Configuration",id:"configuration",children:[]},{value:"Rate Limiter Configuration Factory",id:"rate-limiter-configuration-factory",children:[]},{value:"Rate Limiter Factory",id:"rate-limiter-factory",children:[]},{value:"Token storage",id:"token-storage",children:[]},{value:"Strategy",id:"strategy",children:[]}]},{value:"Strategy",id:"strategy-1",children:[{value:"Sliding window",id:"sliding-window",children:[]}]},{value:"Usage",id:"usage",children:[{value:"Example of usage in middleware",id:"example-of-usage-in-middleware",children:[]},{value:"Example of usage in EventSubscriber",id:"example-of-usage-in-eventsubscriber",children:[]},{value:"Rate Limiter HTTP Headers",id:"rate-limiter-http-headers",children:[]}]}],l={toc:c};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The rate limiter is responsible for limiting the rate of requests a user can make to the application within a given time period. This is useful for preventing a user from spamming the application, but mainly to control the amount of requests a user is allowed to make. The rate limiter is configured in the ",Object(a.b)("inlineCode",{parentName:"p"},"etc/config/security.yaml")," file."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"rate_limit:\n  enabled: true\n  enable_default: true\n  default_limit: 10\n  default_period: 60\n  default_strategy: sliding_window\n  rates:\n    - { name: foo_bar, strategy: sliding_window, limit: 30, period: 60 }\n")),Object(a.b)("p",null,"Rate limits are measured using a ",Object(a.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Token_bucket#:~:text=The%20token%20bucket%20is%20an,variations%20in%20the%20traffic%20flow"},"token bucket algorithm"),". The limit is the maximum number of tokens that can be stored in the bucket. The period is the time in seconds that the bucket is allowed to hold tokens. The strategy is the algorithm used to determine the number of tokens that are added to the bucket."),Object(a.b)("h2",{id:"default-rate-limiter"},"Default Rate Limiter"),Object(a.b)("p",null,"The default rate limiter limits all incoming requests as configured. The ",Object(a.b)("inlineCode",{parentName:"p"},"Swift\\Security\\RateLimiter\\Kernel\\Middleware\\RateLimitingMiddleware")," middleware is responsible for adding the default rate limiter to the request. The default_limit, default_period and default_strategy are configured in the ",Object(a.b)("inlineCode",{parentName:"p"},"etc/config/security.yaml")," file. Default rate limiter is disabled by default. To enable it, set ",Object(a.b)("inlineCode",{parentName:"p"},"default_enabled: true")," in the ",Object(a.b)("inlineCode",{parentName:"p"},"rate_limit")," section. "),Object(a.b)("p",null,"By default, each request consumes one token. "),Object(a.b)("h3",{id:"graphql-rate-limiter"},"GraphQL Rate Limiter"),Object(a.b)("p",null,"GraphQl requests consume at least one token, however this is calculated based on the complexity of the query. The complexity of the query is determined by the number of fields in the query divided by 100. For example, a query with 100 fields will consume 1 token. A query with 200 fields will consume 2 tokens. The minimum is 1 token. A query with 170 fields, will consume 2 tokens (170 / 100 = 1.7). This will round off at 2 tokens."),Object(a.b)("h2",{id:"custom-rate-limiter"},"Custom Rate Limiter"),Object(a.b)("p",null,"There's a dozen of reasons to use a custom rate limiter. The most common is to limit the rate of requests to a specific endpoint, or you might want to limit the rate of requests to a specific user. You can still combine this with the default rate limiter. An example of this is Login throttling."),Object(a.b)("h3",{id:"configuration"},"Configuration"),Object(a.b)("p",null,"The easiest way to configure a custom rate limiter is to add a new rate to the ",Object(a.b)("inlineCode",{parentName:"p"},"rates")," array in the ",Object(a.b)("inlineCode",{parentName:"p"},"rate_limit")," section of the ",Object(a.b)("inlineCode",{parentName:"p"},"etc/config/security.yaml")," file."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"  rates:\n    - { name: foo_bar, strategy: sliding_window, limit: 30, period: 60 }\n")),Object(a.b)("p",null,"The RateLimiterFactory will now look for a rate with the name ",Object(a.b)("inlineCode",{parentName:"p"},"foo_bar")," and return a RateLimiter configured as such. "),Object(a.b)("h3",{id:"rate-limiter-configuration-factory"},"Rate Limiter Configuration Factory"),Object(a.b)("p",null,"The RateLimiterConfigurationFactory is responsible for creating RateLimiterConfigurationInterface instances. These represent the configuration for a rate limiter."),Object(a.b)("h4",{id:"example"},"Example"),Object(a.b)("p",null,"This example shows how Swift uses the RateLimiterConfigurationFactory to create a RateLimiterConfigurationInterface instance for the custom configured rate limiter through configuration."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-php"},"<?php declare( strict_types=1 );\n\nnamespace Swift\\Security\\RateLimiter\\Factory;\n\nuse Swift\\DependencyInjection\\Attributes\\Autowire;\n\n#[Autowire]\nclass ConfigurationFactory implements \\Swift\\Security\\RateLimiter\\Factory\\RateLimiterConfigurationFactoryInterface {\n    \n    public function __construct(\n        protected \\Swift\\Configuration\\ConfigurationInterface $configuration,\n    ) {\n    }\n    \n    public function create( string $name, string $stateId ): ?RateLimiterConfigurationInterface {\n        $config = $this->configuration->get( 'rate_limit.rates', 'security' );\n        \n        if ( ! isset( $config[ $name ] ) ) {\n            return null;\n        }\n        \n        return new RateLimiterConfiguration(\n            $name,\n            $config[ $name ][ 'strategy' ],\n            $stateId,\n            $config[ $name ][ 'limit' ],\n            new \\DateInterval( 'PT' . $config[ $name ][ 'period' ] . 'S' ),\n        );\n        \n    }\n    \n}\n")),Object(a.b)("h3",{id:"rate-limiter-factory"},"Rate Limiter Factory"),Object(a.b)("p",null,"The RateLimiterFactory is responsible for creating RateLimiterInterface instances based on the RateLimiterConfigurationInterface."),Object(a.b)("h4",{id:"example-1"},"Example"),Object(a.b)("p",null,"This example shows how Swift uses the RateLimiterFactory to create a RateLimiterInterface instance."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-php"},"<?php declare( strict_types=1 );\n\nnamespace Swift\\Security\\RateLimiter\\Strategy;\n\nuse Swift\\DependencyInjection\\Attributes\\Autowire;\nuse Swift\\Security\\RateLimiter\\Factory\\RateLimiterConfigurationInterface;\nuse Swift\\Security\\RateLimiter\\RateLimiterInterface;\nuse Swift\\Security\\RateLimiter\\Storage\\DatabaseTokenStorage;\n\n#[Autowire]\nclass CoreStrategyFactory implements RateLimiterStrategyFactoryInterface {\n    \n    public function __construct(\n        protected DatabaseTokenStorage $databaseTokenStorage,\n    ) {\n    }\n    \n    public function create( RateLimiterConfigurationInterface $configuration ): ?RateLimiterInterface {\n        return match ( $configuration->getStrategy() ) {\n            SlidingWindowStrategy::NAME, SlidingWindowStrategy::class => new SlidingWindowStrategy(\n                $configuration->getName(),\n                $configuration->getStateId(),\n                $configuration->getLimit(),\n                $configuration->getInterval(),\n                $this->databaseTokenStorage,\n            ),\n            \n            default => null,\n        };\n    }\n    \n}\n")),Object(a.b)("h3",{id:"token-storage"},"Token storage"),Object(a.b)("p",null,"The TokenStorage is responsible for storing and fetching token buckets. By default, the TokenStorage is a DatabaseTokenStorage, but a custom TokenStorage can be used."),Object(a.b)("h4",{id:"example-2"},"Example"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-php"},"<?php declare( strict_types=1 );\n\nnamespace Swift\\Security\\RateLimiter\\Storage;\n\nuse Swift\\DependencyInjection\\Attributes\\Autowire;\nuse Swift\\Security\\RateLimiter\\TokenBucketInterface;\n\n#[Autowire]\nclass DatabaseTokenStorage implements StorageInterface {\n    \n    public function __construct(\n        protected \\Swift\\Orm\\EntityManagerInterface $entityManager,\n    ) {\n    }\n    \n    public function persist( TokenBucketInterface $tokenBucket ): void {\n        foreach ( $tokenBucket->getTokens() as $token ) {\n            $this->entityManager->persist( $token );\n        }\n        \n        $this->entityManager->run();\n    }\n    \n    public function fetch( string $name, string $stateId ): ?TokenBucketInterface {\n        $tokens = $this->entityManager->findMany( LimiterTokenEntity::class, [\n            'rateName' => $name,\n            'stateId'  => $stateId,\n        ] );\n        \n        return new DatabaseTokenBucket( $name, $stateId, $tokens );\n    }\n    \n    public function reset( string $name, string $stateId, ?\\DateTimeInterface $before = null ): void {\n        $tokens = $this->entityManager->findMany( LimiterTokenEntity::class, [\n            'rateName' => $name,\n            'stateId'  => $stateId,\n        ] );\n        \n        foreach ( $tokens as $token ) {\n            if ( ( $before !== null ) && ( $token->getCreatedAt() > $before ) ) {\n                continue;\n            }\n            \n            $this->entityManager->delete( $token );\n        }\n        $this->entityManager->run();\n    }\n    \n}\n")),Object(a.b)("h3",{id:"strategy"},"Strategy"),Object(a.b)("p",null,"The Strategy is responsible for calculating the number of tokens to consume. The default strategy is the SlidingWindowStrategy. A custom strategy can be used by implementing the ",Object(a.b)("inlineCode",{parentName:"p"},"Swift\\Security\\RateLimiter\\RateLimiterInterface"),". And defining a factory for initializing the strategy, like the CoreStrategyFactory above."),Object(a.b)("h2",{id:"strategy-1"},"Strategy"),Object(a.b)("p",null,"Strategies are responsible for calculating the number of tokens over a period of time. The default strategy is the SlidingWindowStrategy. This is the strategy that Swift uses by default and is the most common strategy. However, you can create your own strategy and use it by implementing the ",Object(a.b)("inlineCode",{parentName:"p"},"Swift\\Security\\RateLimiter\\RateLimiterInterface"),". An example of another strategy is the FixedWindowStrategy."),Object(a.b)("h3",{id:"sliding-window"},"Sliding window"),Object(a.b)("p",null,"The SlidingWindowStrategy calculated the number of available tokens based on how many tokens were consumed between the moment of the request and the moment of the request minus the interval."),Object(a.b)("p",null,"For example, if a request is made at time ",Object(a.b)("inlineCode",{parentName:"p"},"t")," and the interval is ",Object(a.b)("inlineCode",{parentName:"p"},"1 minute"),". The strategy will fetch all tokens created between ",Object(a.b)("inlineCode",{parentName:"p"},"t - 1 minute")," and ",Object(a.b)("inlineCode",{parentName:"p"},"t"),". It will now withdraw those tokens from the limit and return the number of tokens that can still be consumed."),Object(a.b)("h2",{id:"usage"},"Usage"),Object(a.b)("p",null,"Interaction with the Rate Limiter is done through the ",Object(a.b)("inlineCode",{parentName:"p"},"Swift\\Security\\RateLimiter\\RateLimiterFactory"),". The RateLimiterFactory is responsible for creating RateLimiterInterface instances."),Object(a.b)("h3",{id:"example-of-usage-in-middleware"},"Example of usage in middleware"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-php"},"<?php declare( strict_types=1 );\n\nnamespace Swift\\Security\\RateLimiter\\Kernel\\Middleware;\n\nuse Swift\\Configuration\\ConfigurationInterface;\nuse Swift\\DependencyInjection\\Attributes\\Autowire;\nuse Swift\\Kernel\\Middleware\\KernelMiddlewareOrder;\nuse Swift\\Kernel\\Middleware\\MiddlewareInterface;\nuse Swift\\Security\\RateLimiter\\RateLimit;\nuse Swift\\Security\\RateLimiter\\RateLimiterFactory;\n\n#[Autowire]\nclass RateLimitingMiddleware implements MiddlewareInterface {\n    \n    public function __construct(\n        protected RateLimiterFactory     $rateLimiterFactory,\n        protected ConfigurationInterface $configuration,\n    ) {\n    }\n    \n    public function getOrder(): int {\n        return KernelMiddlewareOrder::RATE_LIMIT;\n    }\n    \n    public function process(\n        \\Psr\\Http\\Message\\ServerRequestInterface $request,\n        \\Psr\\Http\\Server\\RequestHandlerInterface $handler,\n    ): \\Psr\\Http\\Message\\ResponseInterface {\n        // If rate limiting is disabled, skip this middleware\n        if ( ! $this->configuration->get( 'rate_limit.enabled', 'security' ) ) {\n            return $handler->handle( $request );\n        }\n        // If this is a GraphQL request, skip this middleware. GraphQL rate limiting is handled by the QueryComplexityRateLimiter rule.\n        if ( \\Swift\\GraphQl\\Util::isGraphQlRequest( $request ) ) {\n            return $handler->handle( $request );\n        }\n        \n        if ( $this->configuration->get('rate_limit.enable_default', 'security') ) {\n            // Returns a RateLimiterInterface of null if no rate limiter is found.\n            // The utility will automatically fetch a state id, for non-authenticated requests it will use the IP address, for authenticated requests it will use the user uuid.\n            $limiter = $this->rateLimiterFactory->create( 'default', \\Swift\\Security\\RateLimiter\\Util::getStateFromRequest( $request ) );\n            // This will return a Swift\\Security\\RateLimiter\\RateLimit object.\n            $rate = $limiter?->consume( 1 );\n    \n            // This will throw a Swift\\HttpFoundation\\Exception\\TooManyRequestsException if the rate limit is exceeded.\n            // The Kernel will handle this exception and return a 429 response.\n            $rate->denyIfNotAccepted();\n            \n            // Another option is to manually check if the rate limit is exceeded.\n            // if ( $rate->isAccepted() ) { // rate limit is not exceeded }\n        }\n        \n        $response = $handler->handle( $request );\n        \n        // RateLimiter::bindToResponse will add the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers to the response.\n        return RateLimit::bindToResponse( $rate ?? null, $response );\n    }\n    \n}\n")),Object(a.b)("h3",{id:"example-of-usage-in-eventsubscriber"},"Example of usage in EventSubscriber"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-php"},"<?php declare( strict_types=1 );\n\nnamespace Swift\\Security\\Firewall\\EventSubscriber;\n\nuse Swift\\DependencyInjection\\Attributes\\Autowire;\nuse Swift\\Security\\Firewall\\Exception\\LoginThrottlingTooManyAttempts;\nuse Swift\\Security\\User\\Authentication\\Passport\\Stamp\\LoginStamp;\n\n#[Autowire]\nclass CheckPassportSubscriber implements \\Swift\\Events\\EventSubscriberInterface {\n    \n    public function __construct(\n        protected \\Swift\\Security\\RateLimiter\\RateLimiterFactory $rateLimiterFactory,\n    ) {\n    }\n    \n    /**\n     * @inheritDoc\n     */\n    public static function getSubscribedEvents(): array {\n        return [\n            \\Swift\\Security\\Authentication\\Events\\CheckPassportEvent::class => [\n                'loginThrottling',\n            ],\n        ];\n    }\n    \n    /**\n     * Validate the login throttling.\n     *\n     * @param \\Swift\\Security\\Authentication\\Events\\CheckPassportEvent $event\n     *\n     * @return void\n     */\n    public function loginThrottling( \\Swift\\Security\\Authentication\\Events\\CheckPassportEvent $event ): void {\n        if ( ! $event->getPassport()->hasStamp( LoginStamp::class ) ) {\n            return;\n        }\n        \n        $limiter = $this->rateLimiterFactory->create( 'login_throttling', $event->getPassport()->getUser()->getUuid() );\n        $rate    = $limiter?->consume();\n        \n        if ( ! $rate->isAccepted() ) {\n            throw new LoginThrottlingTooManyAttempts( $rate );\n        }\n        \n    }\n    \n}\n")),Object(a.b)("h3",{id:"rate-limiter-http-headers"},"Rate Limiter HTTP Headers"),Object(a.b)("p",null,"It is good practice to add the rate limiter headers to the response. This is easily done by using the RateLimiter::bindToResponse method. Like in the example above, the RateLimiter::bindToResponse method will add the X-RateLimit-Limit, X-RateLimit-Remaining and X-RateLimit-Reset headers to the response."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-php"},"/**\n * Binds rate limit headers to a response.\n *\n * @param \\Swift\\Security\\RateLimiter\\RateLimitInterface|null $rateLimit\n * @param \\Psr\\Http\\Message\\ResponseInterface                 $response\n *\n * @return \\Psr\\Http\\Message\\ResponseInterface\n */\npublic static function bindToResponse( ?RateLimitInterface $rateLimit, ResponseInterface $response ): ResponseInterface {\n    if ( ! $rateLimit ) {\n        return $response;\n    }\n    \n    return $response->withHeader( 'X-RateLimit-Limit', $rateLimit->getLimit() )\n                    ->withHeader( 'X-RateLimit-Remaining', $rateLimit->getAvailableTokens() )\n                    ->withHeader( 'X-RateLimit-Reset', $rateLimit->getResetTime()->getTimestamp() );\n}\n")))}u.isMDXComponent=!0},148:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return f}));var i=n(0),r=n.n(i);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),u=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=u(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=u(n),p=i,f=m["".concat(o,".").concat(p)]||m[p]||d[p]||a;return n?r.a.createElement(f,s(s({ref:t},l),{},{components:n})):r.a.createElement(f,s({ref:t},l))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);